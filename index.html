<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .workbtn {
      margin-right: 10px;
      width: 60px;
    }

    .task-index {
      display: inline-block;
      width: 20px;
      margin: 0;
    }

    .tasklist-item__text {
      display: inline-block;
      width: 90px;
      margin: 0;
    }

    .status-text {
      padding-left: 20px;
    }
  </style>
</head>
<body>
  <h1>ToDoリスト</h1>
  <label for="all">
    <input type="radio" id="all" name="sort-radio" value="all" checked>すべて
  </label>
  <label for="working">
    <input type="radio" id="working" value="working" name="sort-radio">作業中
  </label>
  <label for="done">
    <input type="radio" id="done" value="done" name="sort-radio">完了
  </label>

  <p style="font-weight: bold;">ID コメント <span class="status-text">状態</span></p>
  <ul id="tasklist" style="list-style: none;padding: 0;">
  </ul>
  <h2>新規タスクの追加</h2>
  <input id="task-textbox" type="text">
  <button id="add-btn">追加</button>
  <script>

    {
      'use strict'
      //js課題③
      //DOMから要素を必要な要素取得とタスクを配列管理
      const addTaskBtn = document.getElementById('add-btn');
      const textBox = document.getElementById('task-textbox');
      const taskList = document.getElementById('tasklist');
      const addTaskList = [];

      // 関数まとめ
      //li要素があった場合、li要素のテキストの幅を取得する
      function checkResetLi() {
        if (document.querySelector('.tasklist-item') !== null) {
          const taskTexts = document.getElementsByClassName('tasklist-item__text');//テキストリストのpタグ取得
          const taskTextStyle = window.getComputedStyle(taskTexts[0], '');//指定した要素のstyle情報取得
          const taskTextScale = taskTextStyle.getPropertyValue('width');//widhtの値を検出
          return taskTextScale;
        }
      };

      // 初めてならタスクオブジェクトを繰り返し表示 2回目ならタスクアイテムの追加のみ
      function showList() {
        // ul＞li作成し＞index,タスクテキストのpと作業中と削除のbtn追加
        const taskItem = document.createElement('li');
        const indexText = document.createElement('p');
        const taskText = document.createElement('p');
        const workBtn = document.createElement('button');
        const deconsteBtn = document.createElement('button');
        const taskItemNumber = document.querySelectorAll('.tasklist-item').length;
        const taskItemCollection = taskList.children;
        taskItem.setAttribute('class', 'tasklist-item');
        indexText.setAttribute('class', 'task-index');
        taskText.setAttribute('class', 'tasklist-item__text');
        workBtn.setAttribute('class', 'workbtn working');
        deconsteBtn.setAttribute('class', 'deconstebtn');
        workBtn.textContent = '作業中';
        deconsteBtn.textContent = '削除';
        indexText.textContent = taskItemNumber;
        taskText.textContent = addTaskList[taskItemNumber].task;
        taskItem.appendChild(indexText);
        taskItem.appendChild(taskText);
        taskList.appendChild(taskItem);
        //初回以外は追加したタスクアイテムへボタンを追加
        if (taskItemCollection.length !== 0) {
          taskItemCollection[taskItemNumber].appendChild(workBtn);
          taskItemCollection[taskItemNumber].appendChild(deconsteBtn);
        } else {
          taskItem.appendChild(workBtn);
          taskItem.appendChild(deconsteBtn);
        }
      };

      //タスクリストのオブジェクトのtaskプロパティの文字数最大値を検出
      function dtectionMaxTextLength() {
        if (document.querySelector('.tasklist-item') !== null) {
          const taskLength = Math.max.apply(null, addTaskList.map(function (o) { return o.task.length; }));
          return taskLength;
        }
      };

      // task値の文字数に応じてテキストスケールの幅を可変させる
      function adjustTaskScale() {
        const maxLength = dtectionMaxTextLength();//オブジェクト配列のtaskのプロパティ値のlength取得し最大値を検出する。
        const textScale = maxLength * 20;//文字数に応じて値を増やす
        const taskTexts = document.getElementsByClassName('tasklist-item__text');//テキストリストのpタグ取得
        const status = document.querySelector('.status-text');//状態テキスト要素を取得
        if (textScale > 90) {//文字数が多ければスケールを変更
          status.style.paddingLeft = (textScale - 70) + 'px';//状態テキスを可変させる
          for (let i = 0; i < taskTexts.length; i++) {//タスクテキストスケールを変更
            taskTexts[i].style.width = textScale + 'px';
          }
        } else {//文字数が少なければ初期値に戻す
          status.style.paddingLeft = 20 + 'px';
          for (let i = 0; i < taskTexts.length; i++) {
            taskTexts[i].style.width = 90 + 'px';
          }
        }
      };

      //削除したらindexの順番を変える
      function resetIndex() {
        const taskIndex = document.querySelectorAll('.task-index');//タスクindexを管理してるテキストを検出
        for (let i = 0; i < taskIndex.length; i++) {
          taskIndex[i].textContent = i;
        };
      };

      //イベントまとめ
      //追加ボタンクリックでタスク追加
      addTaskBtn.addEventListener('click', () => {
        // タスクをオブジェクトと配列管理
        function addList(text) {
          const addTask = { task: text };
          addTaskList.push(addTask);
        };
        addList(textBox.value);
        const scale = checkResetLi();//リセットする前のテキストの幅を取得
        showList();// タスクアイテムの表示
        sortTaskList();//radioチェック状況によりタスクリストを表示・非表示にする
        adjustTaskScale();//文字数に応じてタスクテキストスケールを変更する
        textBox.value = '';//テキストボックスを空白にする
      });

      //削除ボタンクリックでbtn親要素とオブジェクト削除 状態ボタンクリックで状態テキスト変更
      taskList.addEventListener('click', e => {
        const deconsteElement = e.target.parentNode;// クリックされた親要素を取得
        if (e.target.className === 'deconstebtn') {//削除ボタンクリック
          const taskItemLists = Array.from(document.querySelectorAll('.tasklist-item'));//htmlコレクションを配列化
          const index = taskItemLists.indexOf(deconsteElement);//クリックされた親要素（li）が何番目か検出
          addTaskList.splice(index, 1);//クリックされたオブジェクト削除
          deconsteElement.remove();//クリックされた親要素削除
          resetIndex();//削除したらindexの順番を変える
          adjustTaskScale();
        } else if (e.target.className = 'workbtn') {//状態ボタンクリック
          if (e.target.textContent === '作業中') {
            e.target.textContent = '完了';
            e.target.classList.add('done');
            sortTaskList();
          } else {
            e.target.textContent = '作業中';
            e.target.classList.add('working');
            sortTaskList();
          }
        }
      });

      //ラジオボタンクリックで並べ替え
      //ラジオ要素取得
      const radioList = document.getElementsByName('sort-radio');//radioグループ取得
      // 作業中ボタン要素取得
      const workingBtn = document.getElementsByClassName('working');
      const doneBtn = document.getElementsByClassName('done');
      //繰り返し処理まとめ 作業中ボタンの親要素を表示/非表示 完了ボタンの親要素を表示/非表示
      function sortWorking(text) {
        for (let i = 0; i < workingBtn.length; i++) {
          workingBtn[i].parentNode.style.display = text;
        }
      }
      function sortDone(text) {
        for (let i = 0; i < doneBtn.length; i++) {
          doneBtn[i].parentNode.style.display = text;
        }
      }

      //どのradioボタンが選択されたかを調べて表示、非表示にする。
      function sortTaskList() {
        for (let i = 0; i < radioList.length; i++) {
          if (radioList[i].checked) {
            if (radioList[i].value === 'done') {//完了のみ表示する
              sortWorking('none');
              sortDone('block')
            } else if (radioList[i].value === 'working') {//作業中のみ表示
              sortWorking('block');
              sortDone('none');
            } else { //全て表示する
              sortWorking('block');
              sortDone('block')
            }
          }
        }
      }
      //radioボタンクリック時にタスクをソートする
      for (let i = 0; i < radioList.length; i++) {
        radioList[i].addEventListener('click', () => {
          sortTaskList();
        });
      }
    }
  </script>
</body>
</html>
